using Microsoft.AspNetCore.Mvc;
using WebApplicationHomework9.Models;

namespace WebApplicationHomework9.Controllers
// Чтобы этот контроллер обрабатывал входящие запросы и привратился
// в настоящий контроллер нужно выполнить несколько настроек
// Нужно унаследовать этот класс от ControllerBase и если нужно
// подключить using Microsoft.AspNetCore.Mvc
// Так же можно косвенно указать приложению на то, что class
// WeatherForecastController является контроллером, если указать
// атребут [ApiController]
// Атребуты можно вешать на классы, можно вешать на методы
// В данном случае атребут будит говорить, что class
// WeatherForecastController является настоящим классом
// Так же можно дабавить отребут [Route()] и в рамках этого
// атребута мы можем указать некоторый маршрут например "api/weather"
// и когда мы обратимся на некий сервер например
// http://localhost:5051/api/weather мы немедленно попадём на этот
// контроллер
{
    [Route("api/weather")]
    [ApiController]
    public class WeatherForecastController : ControllerBase
    {
        // Теперь когда мы создали основные методы свяжем наши
        // элементы
        // Создадим новый конструктор и передадим туда экземпляр
        // холдера
        private WeatherHolder holder;

        public WeatherForecastController(WeatherHolder holder)
        {
            this.holder = holder;
        }

        // Конечные запросы обрабатывают методы они называются методы
        // действий
        // В рамках нашего класса опишем поведение или некоторые
        // методы например add
        // В рамках этого метода мы можем передать информацию о дате
        // текущей фиксации погоды (DateTime date) и информацию о
        // температуре (int temperatureC)

        [HttpPost("add")] // мы указали, что у метода Add будит тип
                          // Post и конечный маршрут запроса "add"
        public IActionResult Add(DateTime date, int temperatureC)
        {
            holder.Add(date, temperatureC);
            return Ok(); // возвращает статус ответа http 200

        }

        // Создадим ещё методы
        // Каждый метод может вызываться в контексте определённого
        // маршрута
        // Каждый метод, который мы описываем должен иметь
        // определённый тип например get, post, put, delete и так далее
        // Можно всем методам присвоить тип get, но так делать
        // непрофессионально и это плохой тон
        // Методы могут называться как угодно

        [HttpPut("update")] // когда метод изменяет какие либо
                            // данные атребут Put
        public IActionResult Update(DateTime date, int temperatureC)
        {
            holder.Update(date, temperatureC);
            return Ok();

        }

        [HttpDelete("delete")] // когда метод удаляем данные в рамках
                               // нашего интерфейса
        public IActionResult Delete(DateTime date)
        {
            holder.Delete(date);
            return Ok();

        }

        [HttpGet("get")] // когда метод ни чего не модифицирует,
                         // не изменяет, а просто возвращает дынные
                         // Так же можем воспользуемся не только
                         // интерфейсом IActionResult,
                         // но и таким объектом, как просто
                         // ActionResult бывает обычная
                         // версии ActionResult и обобщённая
                         // ActionResult<>
                         // В рамках обобщённой версии можно
                         // указать, какой тип ответа мы
                         // собираемся возвращать
        public ActionResult<List<WeatherForecast>> Get(DateTime dateFrom,
                                                       DateTime dateTo)
        {
            List<WeatherForecast> list = holder.Get(dateFrom,
                                                    dateTo);
            // Метод окей прергруженный и имеет два варианта
            // написания без параметра Ok() и с пораметром
            // Ok(object?value)
            // блогодоря этому мы можем вернуть коллекцию
            return Ok(list);

        }

        // Теперь каждый метод имеет определённый тип и когда нам
        // потребуется обратиться к какому либо методу например к
        // методу Add() сначала в строке запроса пропишим POST, а
        // далее пропишим адресс этого метода
        // http://localhost:5051/api/weather/add, если всё совпадает
        // мы попадаем на соответствующий контроллер и
        // соответствующий метод

        // Когда клиент посылает запрос в рамках протокола http и
        // нашего RestApi, то он всегда получает ответ, поэтому
        // мало обработать запрос нужно всегда возвращать ответ
        // поэтому если наш класс является контроллером, то в рамках
        // работы с контроллерами доступен интерфейс IActionResult
        // и теперь каждый наш метод действия способен не только
        // обрабатывать, какие то конкретные запросы, но и возвращать
        // результат ответа

        // Особенность ООП можно создавать переменную не только типа
        // класса, но и типа интерфейса
    }
}
